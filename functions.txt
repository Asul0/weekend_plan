async def refine_plan_node(state: AgentState) -> AgentState:
    """
    Узел-Исполнитель v4.0. Обрабатывает фильтрацию (>, <) и создает
    инструкции по сортировке (MIN, MAX) для PlanBuilder.
    """
    command: Optional[ChangeRequest] = state.get("last_structured_command")
    logger.info(
        f"--- УЗЕЛ: refine_plan_node ---. Команда: {command.model_dump_json(indent=2)}"
    )

    if not command or command.command != "modify":
        logger.warning("Некорректная или отсутствующая команда.")
        return state

    target_type = command.target
    constraints = command.constraints

    if not target_type or not constraints:
        logger.warning("Пропуск неполной команды 'modify'.")
        return state

    date_key = next(iter(state.get("cached_candidates", {})), None)
    if not date_key:
        state["error"] = "Кэш кандидатов пуст, не могу выполнить изменение."
        logger.error(state["error"])
        return state

    for constr in constraints:
        if constr.operator in ["MIN", "MAX"]:
            logger.info(
                f"Создание инструкции по сортировке: {constr.operator} для '{target_type}' по '{constr.attribute}'"
            )
            state["sorting_preference"] = {
                "target": target_type,
                "attribute": constr.attribute,
                "order": constr.operator,
            }
            continue

        all_candidates = state["cached_candidates"][date_key].get(target_type, [])
        logger.info(
            f"Фильтрация {len(all_candidates)} кандидатов для '{target_type}' по '{constr.attribute} {constr.operator} {constr.value}'"
        )

        try:
            precise_filtered = _apply_constraint(all_candidates, constr)

            if not precise_filtered and constr.attribute == "start_time":
                logger.info(
                    "Точных совпадений по времени нет, расширяю диапазон поиска на ±15 минут."
                )
                filtered_candidates = _apply_constraint(
                    all_candidates, constr, expansion_minutes=15
                )
                if filtered_candidates:
                    state["plan_warnings"] = (state.get("plan_warnings") or []) + [
                        "Не нашлось вариантов на точное время, но я подобрал ближайший."
                    ]
            else:
                filtered_candidates = precise_filtered

            logger.info(
                f"После фильтрации осталось {len(filtered_candidates)} кандидатов."
            )
            if not filtered_candidates:
                state["plan_warnings"] = (state.get("plan_warnings") or []) + [
                    f"Не удалось найти вариантов для '{target_type}' по вашим новым критериям."
                ]

            state["cached_candidates"][date_key][target_type] = filtered_candidates
        except Exception as e:
            logger.error(f"Ошибка при применении ограничения: {e}", exc_info=True)
            state["error"] = "Ошибка при поиске по новым критериям."
            return state

    if target_type in state.get("pinned_items", {}):
        del state["pinned_items"][target_type]
        logger.info(
            f"Элемент '{target_type}' откреплен (unpinned) для перепланирования."
        )

    # План больше не сбрасывается здесь. BUILD_PLAN будет вызван следующим.
    logger.info("Узел refine_plan_node завершил работу. Переход к BUILD_PLAN.")
    return state
